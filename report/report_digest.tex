% utf-8 ru, unix eolns
\documentclass[12pt,a4paper,oneside]{extarticle}
    \righthyphenmin=2 %минимально переносится 2 символа
    \sloppy

\usepackage{geometry} % А4, примерно 28-31 строк(а) на странице 
    \geometry{paper=a4paper}
    \geometry{includehead=false} % Нет верх. колонтитула
    \geometry{includefoot=true}  % Есть номер страницы
    \geometry{bindingoffset=0mm} % Переплет    : 0  мм
    \geometry{top=20mm}          % Поле верхнее: 20 мм
    \geometry{bottom=25mm}       % Поле нижнее : 25 мм 
    \geometry{left=30mm}         % Поле левое  : 30 мм (статья)
    \geometry{right=30mm}        % Поле правое : 30 мм (статья)
    \geometry{headsep=10mm}  % От края до верх. колонтитула: 10 мм
    \geometry{footskip=20mm} % От края до нижн. колонтитула: 20 мм 

\usepackage{cmap}
\usepackage[T2A]{fontenc} 
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{misccorr}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\setlength{\parindent}{1.25cm}  % Абзацный отступ: 1,25 см
\usepackage{indentfirst}        % 1-й абзац имеет отступ

\usepackage{setspace}   

\onehalfspacing % Полуторный интервал между строками

\usepackage{clrscode}% псевдокод 

\makeatletter
\renewcommand{\@oddfoot }{\hfil\thepage\hfil} % Номер стр.
\renewcommand{\@evenfoot}{\hfil\thepage\hfil} % Номер стр.
\renewcommand{\@oddhead }{} % Нет верх. колонтитула
\renewcommand{\@evenhead}{} % Нет верх. колонтитула
\makeatother

\usepackage{fancyvrb}

\usepackage[pdftex]{graphicx}  % поддержка картинок 
   \usepackage{epstopdf}
   \DeclareGraphicsRule{.eps}{pdf}{.pdf}{`epstopdf #1}


\usepackage{syntax} %для поддержки рбнф
\setlength{\grammarindent}{12em} %устанавливает нужный отступ перед ::=
\setlength{\grammarparsep}{6pt plus 1pt minus 1pt}  %сокращает расстояние между правилами

\renewcommand{\labelenumi}{\theenumi.} %меняет вид нумерованного списка

\usepackage{perpage} %нумерация сносок 
\MakePerPage{footnote}

\usepackage[all]{xy} %поддержка графов

\usepackage{listings} %поддержка листингов
\renewcommand{\lstlistingname}{Листинг}

\usepackage[usenames]{color}

%
% Обычный размер шрифта в заголовках
%
\usepackage[explicit]{titlesec} 
\titleformat{\section}{\normalfont\bfseries}{\thesection.}{0.5em}{#1}
\titleformat{\subsection}{\normalfont\bfseries}{\thesubsection.}{0.5em}{#1}
\titleformat{\subsubsection}{\normalfont\bfseries}{\thesubsection.}{0.5em}{#1}


\begin{document}
\noindent УДК ...
\bigskip

\noindent\textbf{Препроцессор синаксического сахара для языка Scheme}

\noindent МГТУ им. Н.Э.Баумана\\
Выборнов А.И., Дубанов А.В.\\
art-vybor@ya.ru; qrcs@mail.ru

\noindent\textbf{Аннотация.} В работе рассмотрены создание препроцессора для языка Scheme и разработка входного языка для препроцессора. Препроцессор реализован в виде приложения с консольным интерфейсом. Исходные тексты проекта доступны по адресу: https://github.com/art-vybor/lactose

\noindent\textbf{Ключевые слова:} Lisp, Scheme, Синтаксический сахар, Компилятор, Препроцессор.

\bigskip


\noindent\textbf{Введение.}
    Язык Lisp создавался в ходе работ по созданию искусственного интеллекта, но сейчас сфера его применения выходит далеко за пределы этой узкой области. Lisp это функциональный язык с динамической системой типов.
    Его отличительной особенностью является то, что программы и данные являются списками символов.
    Программа на языке Lisp представляет собой уже синтаксическое дерево, что облегчает создание парсеров этого языка.

    В настоящее время Lisp представляет собой целое семейство языков программирования.
    В данной работе рассматривается Scheme, удолетворяющий стандарту r5rs~\cite{r5rs}~---~один из наиболее известных диалектов Lisp.
    В Scheme упор был сделан на простоту языка~---~в нём содержиться минимальное количество примитивных конструкций, которые, тем не менее, позволяют выразить любой требуемый функционал.

    Несмотря на простоту языка Scheme, он перегружен большим количеством скобок.
    Также Scheme не поддерживает инфиксную запись выражений, что, к примеру, не позволяет записывать арифметические выражения в привычном виде.
    С другой стороны такие современные языки программирования как Haskell, Python или Erlang, позволяют писать более удобочитаемый код.

    Необходимо разработать входной язык, который привносит в Scheme синтаксические преимущества современных языков программирования.
    также реализовать препроцессор, который по входному языку порождает программу на Scheme.


\noindent\textbf{Входной язык препроцессора.} \textcolor{red}{Эта глава очень, очень неудачно написана. Прошу порекомендовать способ изложения подобного материала и я её перепишу.}
    Программа на входном языке представляет собой множество объявлений функций.
    Переменные также являются функциями.
    Если в корне программы присутствует объявление функции main~---~то эта функция будет интерпретирована как точка входа.
    Токены языка совпадают с токена на языке Sсheme. Рассмотрим более подробное описание входного языка.

    Токены входного языка максимально приближены к токенам Scheme, стандарта r5rs.
    Представлены следующие виды токенов: строка, идентификатор, число, логическая переменная и символ.
    Единственным существенным отличием от Scheme является отсутствие знака перед числом, так как во входном языке знак перед числом определяется с помощью унарных операций.
    Как и в Scheme все токены используются без учёта регистра.
    Примеры токенов: \lstinline$"abc"$, \lstinline$func$, \lstinline$123$, \lstinline$#b010$, \lstinline$#t$, \lstinline$#\a$.

    Базовым понятием синтаксиса языка является выражение.
    В качестве выражения рассматриваются инфиксные операции, условный оператор и вызов функции.
    В дальнейшем выражения будут обозначаться как \lstinline$expr_i$$,i \in \mathbb{N}$.

    Входной язык поддерживает инфиксные операции, аналогичные операциям языка Python.
    Приоритеты операций изменяются с помощью скобок.
    Пример поддерживаемого инфиксного выражения: \lstinline$not (x > 2 and x > 5)$.

    Выражение, задающее условные оператор, записывается следующим образом: \lstinline$if expr_1 then expr_2 else expr_3$.
    Условный оператор возвращает \lstinline$expr_2$, если \lstinline$expr_1$ истиннно, и \lstinline$expr_3$ в противном случае.

    Вызов функции представляется собой последовательность вида: \lstinline$ident arguments$, где \lstinline$ident$~---~идентификатор, задающий имя функции, а \lstinline$arguments$~---~множество аргументов, представляющее собой набор выражений записанных через пробел.
    Пример вызова функции \lstinline$f$ от двух аргументов: \lstinline$f x y+z$.

    Объявление функции представляет собой последовательность вида: \lstinline$def ident: func_body$, где \lstinline$ident$~---~идентификатор, задающий имя функции, а \lstinline$func_body$~---~тело функции.
    Тело функции может задаваться либо множеством выражений, разделённых символом \lstinline$ident$, либо $\lambda$-функция. Пример определения функции \lstinline$abs$ от одного аргумента: \lstinline$def abs x: if x >= 0 then x else -x$.

    Входной язык поддерживает объявление $\lambda$-функций. К примеру, выше описанная функция \lstinline$abs$ аналогична $\lambda$-функции: \lstinline$\x -> if x>0 then x else -x$

    Также поддерживается вставка кода функций на Scheme в виде конструкции: \lstinline${ lisp_code } export names$, где \lstinline$lisp_code$~---~код на языке Lisp, а \lstinline$names$~---~список идентификаторов, разделённых запятой, которые задают имена функци Scheme, которые будут видимы для кода входного языка.


\noindent\textbf{Реализация препроцессора.}
    Компиляция входного языка в Scheme состоит из трёх этапов:

    \begin{enumerate}
        \item Лексический и синтаксический разбор входного языка выполняется с помощью парсера, который создаётся генератором парсеров antlr~\cite{antlr}. 
              На выходе получаем синтаксическое дерево.
        \item Абстрактное синтаксическое дерево входного языка преобразуется в синтаксическое дерево языка Lisp.
              На этом этапе проводится семантический разбор, а именно, проверяется видимость символов~(идентификаторов функций).
        \item По иерархической структуре списков порождается файл, который является программой на Scheme, удовлетворяющей стандарту r5rs. 
    \end{enumerate}

    Препроцессор является многопроходным. На первом проходе строится синтаксическое дерево. На втором синтаксическое дерево преобразуется в дерево языка Lisp.

    Реализована система обработки ошибок. Обработка происходит как во время построения синтаксического дерева с помощью antlr, так и во время семантического анализа и заключается в печати в стандартный поток вывода всех встречаемых ошибок. Если по завершении семантического анализа общее количество ошибок не нулевое, то выполнение компиляции прерывается.
            
    Препроцессор предоставляет интерфейс командной строки: аргументы -i, -o задают имена входного и выходного файла соответственно, ключ --run позволяет проинтерпретировать полученную программу на Scheme, также набор ключей: --stack_trace, --lexem, --console_tree, --pdf_tree параметризируют подробность вывода промежуточных данных, получаемых при лексическом и синтаксическом анализе.


\noindent\textbf{Cравнение входного языка с Scheme.}
    Произведём сравнение входного языка с Scheme на примере реализации двух функций: \lstinline$fact$~---~вычисление факториала по числу и \lstinline$fib$~---~вычисление числа фибоначчи по его номеру. 
    Листинг~\ref{lst:scheme} демонстрирует реализацию этих функций на Scheme, а листинг~\ref{lst:lactose} на входном языке. 

    Как видно из приведённых листингов код входного языка в значительно меньшей степени перегружен скобками, чем Scheme. Также намного более лёгкой для чтения является запись сложных арифметических выражений в инфиксном виде.    
    
    \begin{figure}[h!]    
        \begin{lstlisting}[mathescape,label={lst:scheme},caption={Реализация функций fact и fib на Scheme},captionpos=b]
(define fact (lambda (n) 
    (if (= n 0) 1
                (* n (fact (- n 1))))))

(define (fib n) (/ (- (expt (/ 2 (+ 1 (sqrt 5))) n)
                      (expt (/ 2 (- 1 (sqrt 5))) n))
                    (sqrt 5)))
        \end{lstlisting}
    \end{figure}

    \begin{figure}[h!]  
        \begin{lstlisting}[mathescape,label={lst:lactose},caption={Реализация функций fact и fib на входном языке},captionpos=b]
def fact = \n -> if n == 0 then 1 else n*fact(n-1)

def fib n = ( (1+sqrt(5)/2)**n - (1-sqrt(5)/2)**n ) / sqrt(5)
        \end{lstlisting}
    \end{figure}


\noindent\textbf{Заключение} 
    В рамках данной работы была сделана попытка освежить Sсheme, добавить ему элегантности, сделать код более удобочитаемым.
    Для этого был разработан входной язык, обладающий синтаксическим сахаром, позаимствованным из Haskell и Python.
    С помощью написанного препроцессора, входной язык комплируется в Sсheme.

    Полученный входной язык представляет академический интерес и не пригоден для практического применения.

    \textcolor{red}{хочется ещё предложение добавить, правда не знаю о чём}


\begin{thebibliography}{00}
\addcontentsline{toc}{section}{Литература}
    \bibitem{r5rs} R. Kelsey, W. Clinger, J. Rees. Revised$^5$ Report on the Algorithmic Language Scheme. Higher-Order and Symbolic Computation, Vol. 11, No. 1, August, 1998
    \bibitem{dragon} Ахо, Альфред В., Лам, Моника С., Сети, Рави, Ульман, Джеффри Д. Компиляторы: принципы, технологии и инструментарий, 2-е изд.: Пер. с англ.~--~М.: ООО <<И.Д.Вильямс>>, 2008~--~1184 с.
    \bibitem{antlr} Terence Parr. The Definitive ANTLR 4 Reference. 2013.
\end{thebibliography}

\end{document}
